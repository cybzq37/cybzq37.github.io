## **指针**

指针类型的实例是一个指针变量，它存储的是内存地址，占用一个地址空间（与机器的字长有关）。

指针变量属于标量类型，因此可以被复制、拷贝、修改，指向不同的对象。

  

### **声明和初始化**

指针变量的声明使用 `*` 运算符，`*` 符号的**左边**表示指针指向的类型，**右边**表示指针的类型。

指针变量可以在声明时初始化为某个对象的地址，也可以不初始化。

```C++
int ival = 42;
int *p = &ival;           // &在这里成为“取地址操作符”
```

### **动态分配内存**

使用`new`运算符可以在堆上动态分配内存，并返回所分配内存的地址。例如`int* ptr = new int;`分配了一个整数的空间，并将其地址赋给`ptr`。

动态分配的内存需要使用`delete`手动释放，以避免内存泄漏。

### **空指针**

空指针是指未指向任何有效对象的指针。可以使用 `nullptr` 或 `NULL`（在 C++11 之前）来表示空指针。

```C++
int *pl = nullptr;        //等价于int *p1 =0;
int *p2 = 0;              //直接将p2初始化为字面常量0
int *p3 = NULL;           //需要#include cstdlib，等价于int *p3 =0;
```

`nullptr`是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。

也可以通过将指针初始化为字面值`0`来生成空指针。

旧程序还会用到一个名为`null`的预处理变量来给指针赋值，这个变量在头文件cstdlib中定义，它的值就是`0`。

### **void 指针**

`void*`一种特殊的指针类型，可用于存放任意对象的地址，c 语言中常利用`void*`实现多态。

### **指针的算术运算**

指针可以进行算术运算，如指针加法和指针减法。

对指针进行加法时，指针的值会根据指向类型的大小进行增加。例如 ptr += 1; 将指针 ptr 向后移动一个元素的大小。

指针减法可以得到两个指针之间的元素个数。例如 int* diff = ptr2 - ptr1; 将 diff 初始化为 ptr2 和 ptr1 之间的元素个数。

### **指针的状态**

指针的值(即地址)应属下列4种状态之一：

1. 指向一个对象。
    
2. 指向紧邻对象所占空间的下一个位置。
    
3. 空指针，意味着指针没有指向任何对象。
    
4. 无效指针，也就是上述情况之外的其他值。
    

### **指针操作符**

取址运算符（Address-of Operator）：`&` 运算符可以用于获取变量的地址。例如 `int num = 42; int* ptr = #` 将 ptr 初始化为 num 的地址。

解引用运算符（Dereference Operator）：`*` 运算符用于解引用指针，即访问指针所指向的内存位置的值。例如 `int value = *ptr;` 将 value 初始化为 ptr 指向的内存位置的值。

```C++
int i =42;
int &r =i;         //&紧随类型名出现，因此是声明的一部分，r是一个引用
int *p;            //*紧随类型名出现，因此是声明的一部分，p是一个指针
p =&i;             //&出现在表达式中，是一个取地址符
*p =i;             //*出现在表达式中，是一个解引用符
int &r2 =*p;       //&是声明的一部分，*是一个解引用符
```

符号的上下文决定了符号的意义，在声明语句中，`&`和`*`用于组成复合类型；在表达式中，它们的角色又转变成运算符。

### 指向普通函数的指针

  

### 指向对象成员函数的指针

  

## **引用**

引用的本质是别名，它没有自己的存储空间。它只是对象的一个别名，因此不需要为其分配内存。

```C++
int ival = 1024;
int &refVal = ival;  //refVal指向ival
int &refVal2;        //报错，引用类型必须初始化
```

**引用必须初始化**：一般在进行**初始化操作**时，初始值会被拷贝到新建的对象或变量中。而定义引用时，程序把**引用**和它的**初始值**绑定（bind）在一起，一旦初始化完成，则无法修改，因此引用必须初始化。

**引用的类型必须与其所引用对象的类型一致**，但是有两个例外：

1. **常量引用初始化时：**允许使用任意表达式作为初始值，只要表达式的结果能够转换成引用的类型即可，也允许一个常量引用绑定非常量的对象、字面值或表达式。
    

```C++
int i =42;  
const int &r1 =i;           //允许将const int&绑定到一个普通int对象上
const int &r2 =42;     //正确：r1是一个常量引用
const int &r3 =rl *2;  //正确：r3是一个常量引用
int &r4 =rl*2;         //错误：r4是一个普通的非常量引用
```

临时量的情况

```C++
double dval = 3.14;
const int &r5 = dval;
```

r5 的类型是整型引用，初始化却是一个 double 类型，为了确保 ri 绑定的是一个整数，编译器会进行如下操作：

```C++
const int temp =dval; //由双精度浮点数生成一个临时的整型常量
const int &r5 =temp;  //让ri绑定这个临时量
```

这种情况下，ri 先绑定了一个**临时量（temporary）**，编译器创建的一个临时空间用来暂存表达式的结果。

1. **存在继承关系的类**：可以将基类的指针或引用绑定到派生类对象上。
    

### **对指针的引用**

引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：

```C++
int i = 42;
int *p;                    //p是一个int型指针
int*& r = p;        //r是一个对指针p的引用
r = &i:                    //r引用了一个指针，因此给r赋值&i就是令p指向i
*r = 0;                    //解引用r得到i,也就是p指向的对象，将i的值改为0
```

要理解`r`的类型到底是什么,最简单的办法是从右向左阅读`r`的定义。离变量名最近的符号（此例中是`&r`的符号`&`）对变量的类型有最直接的影响，因此`r`是一个引用。声明符的其余部分用以确定`r`引用的类型是什么，此例中的符号`*`说明`r`引用的是一个指针。最后，声明的基本数据类型部分指出`r`引用的是一个int指针。

  

数组的引用和引用的数组

```C++
//array首先向右结合，所以这个相当于 (int&)array[] array是个数组，其中的元素是引用
//应该叫：引用的数组
int &array[]

//array首先和&结合，所以array是引用，引用的对象是数组
//应该叫作数组的引用
int (&array)[10] 
```

  

## **const 限定符**

**对 const 的引用可能引用一个并非 const 的对象**

常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身未做限定。

```C++
int i =42;
int &rl =i;        // 引用ri绑定对象i
const int 6r2 =i;  // r2也绑定对象i,但是不允许通过r2修改i的值
rl =0;             // r1并非常量，i的值修改为0
r2 =0;             // 错误：r2是一个常量引用
```

**指针和 const**

指针可以指向常量或非常量， **指向常量的指针(pointer to const)**不能够用于改变其所指对象的值，想要存放常量对象的地址，只能使用指向常量的指针。

```C++
const double pi =3.14;       // pi是个常量，它的值不能改变
double *ptr =π               // 错误：ptr是一个普通指针
const double *cptr =π        // 正确：cptr可以指向一个双精度常量
cptr =42;                    // 错误：不能给cptr赋值
```

指针的类型必须与其所指对象的类型一致，但是有两个例外。

第一种情况是允许一个指向常量的指针指向一个非常量对象。

```C++
double dval =3.14;  //dval是一个双精度浮点数，它的值可以改变
cptr =&dval;  //正确：但是不能通过cptr改变dval的值
```

和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。

试试这样想吧：所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。

**const 指针**

指针是对象而引用不是，因此就像其他对象类型一样，允许把指针本身定为常量。常量指针(const pointer)必须初始化，而且一旦初始化完成，则它的值(也就是存放在指针中的那个地址)就不能再改变了。把*放在const关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：

```C++
int errNumb =0;   //curErr将一直指向errNumb
int *const curErr = &errNumb;
const double pi = 3.14159;
const double *const pip = π;  //pip是一个指向常量对象的常量指针
```

要想弄清楚这些声明的含义最行之有效的办法是从右向左阅读。此例中，离curErr最近的符号是const,意味着curErr本身是一个常量对象，对象的类型由声明符的其余部分确定。

指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。例如，pip是一个指向常量的常量指针，则不论是pip所指的对象值还是pip自己存储的那个地址都不能改变。相反的，curErr指向的是一个一般的非常量整数，那么就完全可以用curErr去修改errNumb的值：

```C++
//错误：pip是一个指向常量的指针
//如果curErr所指的对象(也就是errNumb)的值不为0
*pip =2.72;
```

**顶层 const** 指针本身是不是常量以及指针所指的是不是一个常量就是两个相互独立的问题。

用名词顶层const(top-level const)表示指针本身是个常量，

而用名词底层const(low-level const)表示指针所指的对象是一个常量。

更一般的，顶层const可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层const则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const,这一点和其他类型相比区别明显：

```C++
int i =0;
int *const pl =&i;  //不能改变p1的值，这是一个顶层const
const int ci =42;   //不能改变ci的值，这是一个顶层const
const int *p2 =&ci; //允许改变p2的值，这是一个底层const
const int *const p3=p2; //靠右的const是顶层const,靠左的是底层const
const int &r =ci;  //用于声明引用的const都是底层const
```

**constexpr 和常量表达式**

**[https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-type-system-modern-cpp?view=msvc-170](https://learn.microsoft.com/zh-cn/cpp/cpp/cpp-type-system-modern-cpp?view=msvc-170)**

**类型处理**

定义类型别名（type alias）的方法

使用 `typedef`

使用 `using`（C++11 新标准）

```C++
typedef char* pstring;
const pstring cstr = 0; // cstr 是指向char的常量指针（
**const被识别为顶层const**
）
using int32_t = int
```

`auto` 类型说明符

c++ 11 新标准引入了auto类型说明符， 能让编译器替我们分析表达式所属的类型。另外，因为一条声明语句只能有一个基本类型，所以该语句的所有变量的初始基本类型都必须一样。

```C++
auto i =0, *p = &i;
auto i = 0, j = 3.14;  // 错误，i和j的类型不一致。
```

`decltype`类型说明符

c++ 11 引入了decltype，它的作用是选择并返回操作数的数据类型。 decltype 使用表达式是一个变量时，会返回该变量的类型（包括顶层const和引用）

```C++
const int ci = 0;
decltype(ci) x = 0;     // x的类型是const int
int i = 1, *p = &i;
decltype(*p) c;         // 错误，c是int&， 必须初始化
```

另外， 我们知道 解引用指针 可以得到指针所指的对象， 而且还能给这个对象赋值， 所以 decltype(*p) 的结果是int& 而非 int。

```C++
decltype((i)) d;   // 错误，d 是int&， 必须初始化
decltype(i)   e;   // 正确，e 为int
```

如果给变量加上了一层或多层括号， 编译器就会把它当成表达式。 变量是一种可以作为赋值语句左值的特殊表达式， 所以decltype 会得到引用类型。

## **常量**

**修饰变量****：**说明该变量不可以被改变；

**修饰指针****：**分为指向常量的指针和常量指针；

**修饰引用****：**常量引用，经常用于形参类型，即避免了拷贝，又避免了函数对值的修改；

**修饰成员函数****：**说明该成员函数内不能修改成员变量；

### **常量修饰变量**

`const int bufSize = 512; //输入缓冲区大小`

以这种方式定义时，编译器将在编译过程中把用到该变量的地方替换成对应的值。

为了完成替换，编译器必须知道变量的初始值。如果程序包含多个文件，则每个文件都能要能反问 `const`对象的初始值。

默认情况下， const 对象仅在文件内有效，当多个文件中出现了同名的 const 变量时，等同于在不同的文件中分别定义了独立的变量。

**多个文件之间共享 const 对象**

const 对象的初始值不是一个常量表达式，需要在文件之间共享，声明时添加 extern 关键字。

```C++
// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize;
```

  

### **常量指针**

**`const int* p`**是一个指向**常量整数**的指针，指针 p 可以指向一个整数，但不能通过 p 修改指向的整数的值。也就是说，`p` **是可变的，但是它指向的值是不可修改的**。

```C++
const int value = 10;
const int* p = &value;
```

  

**`int* const p`**是一个常量指针，指针 `p` 是不可变的，它始终指向同一个地址。但是，通过 p 可以修改指向的整数的值。也就是说，`p` **是不可变的，但是它指向的值是可变的**。例如：

```C++
int value = 10;
int* const p = &value;
```

  

**`const int* const p`**是一个常量指针，指向一个常量整数，指针 `p` 是不可变的，并且它指向的值也是不可修改的。

```C++
const int value = 10;
const int* const p = &value;
// *p = 20; // 错误，不能通过 p 修改所指向的值
```

### **常量引用**

避免复制：常量引用可以在不复制对象的情况下使用对象的值，可以避免在函数调用或表达式中复制大型对象的开销，这对于参数传递和函数返回值特别有用，可以提高性能并减少内存消耗。

保护被引用对象：常量引用可以防止被引用的对象被意外修改。如果将一个对象通过常量引用传递给函数，那么函数内部无法修改该对象的值。

#### **基础用法**

```C++
void printValue(const int& value) {
    // 使用常量引用打印值，避免复制
    std::cout << value << std::endl;
}
void modifyValue(const int& value) {
    // 错误示例：无法修改被常量引用的对象
    // value = 10; // 编译错误
}
int main() {
    int num = 5;
    printValue(num); // 通过常量引用打印值
    const int& constRef = num;
    // 错误示例：无法通过常量引用修改常量对象
    // constRef = 10; // 编译错误
    int& nonConstRef = const_cast<int&>(constRef);
    nonConstRef = 10; // 通过类型转换修改常量对象
    printValue(num); // 打印修改后的值
    return 0;
}
```

#### **转为非常量引用**

**常量引用**可以通过**类型转换**来获取**非常量引用**，从而修改常量对象。这在一些特殊情况下是有用的，比如修改传入函数的临时对象。

```C++

int main() {
    int num = 5;
    const int& constRef = num;
    int& nonConstRef = const_cast<int&>(constRef);
    nonConstRef = 10; // 通过类型转换修改常量对象
    printValue(num); // 打印修改后的值
    return 0;
}
```

### **常量成员函数**

const关键字可以用于修饰成员函数，表示该成员函数不会修改对象的状态。这样的成员函数被称为**常量成员函数**，只能调用其他常量成员函数或只读数据成员，不能修改数据成员的值，以确保对象在调用常量成员函数时保持不变。

```C++
class MyClass {
public:
    void foo() const {
        // 只读操作，不修改成员变量
    }
};
```

### **示例代码 1**

```C++
// 类
class A {
public:
    A() : a(0) { };             // 构造函数
    A(int x) : a(x) { };        // 初始化列表
    // const可用于对重载函数的区分
    int getValue();             // 普通成员函数
    int getValue() const;       // 常量成员函数（或叫const成员函数），不得修改类中的任何数据成员的值
private:
    const int a;                // 常量对象成员，只能在初始化列表赋值
};
void fun() {
    // 对象
    A b;                        // 普通对象，可以调用全部成员函数、更新常成员变量
    const A a;                  // 常量对象，只能调用常成员函数
    const A *p = &a;            // 常量指针
    const A &q = a;             // 常量引用
    // 指针
    char greeting[] = "Hello";
    char* p1 = greeting;                // 指针变量，指向字符数组变量
    const char* p2 = greeting;          // 指针变量，指向字符数组常量
    char* const p3 = greeting;          // 常量指针，指向字符数组变量
    const char* const p4 = greeting;    // 常量指针，指向字符数组常量
}
// 函数
void fun1(const int Var);           // 传递过来的参数在函数内不可变
void fun2(const char* Var);         // 参数指针所指内容为常量
void fun3(char* const Var);         // 参数指针为常指针
void fun4(const int& Var);          // 引用参数在函数内为常量
// 函数返回值
const int fun5();      // 返回一个常数
const int* fun6();     // 返回一个指向常量的指针变量，使用：const int *p = fun6();
int* const fun7();     // 返回一个指向变量的常指针，使用：int* const p = fun7();
//const修饰函数时的重载
//实际上没有区别，因为函数调用的时候，存在形实结合的过程，所以不管有没有const都不会改变实参的值。所以不能通过编译，提示重定义。
void fun(const int i);
void fun(int i);
//char *a 中a指向的是一个字符串变量，而const char *a指向的是一个字符串常量，所以当参数为字符串常量时，调用第二个函数，而当函数是字符串变量时，调用第一个函数。
void fun(char *a);    
void fun(const char *a);
//这两个都是指向字符串变量，不同的是char *a是指针变量 而char *const a是指针常量。所以不能通过编译，提示重定义。
void fun(char *a);  
void fun(char * const a);  
//原因是第一个i引用的是一个变量，而第二个i引用的是一个常量，两者是不一样的，类似于上面的指向变量的指针的指向常量的指针。
void fun(int &i);  
void fun(const int &i);   
```

### **示例代码 2**

```C++
const int& funs() const
```

- **`const int&`**：这是返回类型的部分。它表示该函数返回一个指向 `int` 类型对象的常量引用。意味着函数返回一个对某个 int 对象的只读引用。
    
- **`funs()`**：这是函数的名称。函数名为 funs。
    
- **`const`**：这是函数的修饰符，它位于函数括号之后。它表示该函数是一个 const 成员函数，即在该函数内部不能修改非静态数据成员（除非它们被声明为 `mutable`）。