# 编译链接知识

预处理 > 编译 > 汇编 > 链接

- 预处理：引入头文件、去除注释、宏替换、条件编译指令、添加行号、保留所有的编译器指令；
    
- 编译：经过词法分析、语法分析、语义分析、符号汇总生成汇编代码。
    
- 汇编：将汇编代码 `.s` 翻译成机器指令 `.o` 文件。
    
- 链接：链接目标文件，生成可被系统加载执行的ELF文件 `.a` 。


静态链接 & 动态链接

静态链接：静态链接库一般以 .a 文件，我们可以将多个 .o 文件链接成一个静态链接库。

动态链接：动态链接库一般以 .so 文件，我们可以将多个 .o 文件链接成一个动态链接库。

交叉编译

# 内存知识

目标文件（可执行文件、共享库、静态库）& ELF文件格式

进程内存布局

堆与栈

内存对齐

内存泄漏与预防

# 基础知识

关键字 & 类型 & 标识符 & 运算符

表达式 & 语句

声明 & 定义 & 初始化

指针 & 引用

静态数组 & 动态数组 & 多维数组

变量定义与生存周期

  

变量

- 声明 & 定义 & 初始化
    
- 作用域（全局、命名空间、文件、类作用域、局部、语句作用域）
    
- 生命周期（在作用域内有效，静态除外）
    
- static修饰（全局、静态全局、局部、静态局部）
    
- const修饰
    

  

字符串（大括号初始化）

  

类型擦除 & 类型转换

  

函数

- 形参与实参（外实内虚）& 可变形参
    
- 形参传递（值、引用、常量引用、指针、数组、函数）
    
- 函数返回（引用「左值」、右值、指针）
    
- 重载（顶层const无法区分、底层const可以区分）
    
- static 修饰
    
- const 修饰
    

常用容器（vector、deque、list、set、multiset、map、multimap、bitset）

命名空间

库

  

# 面向对象

封装 & 继承 & 多态

- 封装：对外提供接口，降低耦合。
    
- 继承：代码复用。
    
- 多态：使编程更加的灵活。

重载 & 重写 & 隐藏

- 重载：函数内部发生在重载。
    
- 隐藏：发生在编译期，派生类中的函数隐藏了基类中的同名函数。
    
    - 如果派生类中的函数与基类中的函数同名，但参数不同，则派生类中的函数隐藏了基类中的函数。
        
    - 如果派生类中的函数与基类中的函数同名，参数也相同，但基类中的函数不是虚函数，则派生类中的函数隐藏了基类中的函数。
        
- 重写：发生在运行时，派生类中的虚函数覆盖了基类中的同名虚函数。
    
    - 派生类中的函数与基类中的函数同名，参数也相同。
        
    - 基类中的函数必须是虚函数。
        
    - 派生类中的函数可以有不同的返回值类型，但必须与基类中的函数的返回值类型兼容。
        
    - 派生类中的函数可以抛出更多的异常，但必须与基类中的函数抛出的异常兼容。
        

  

访问权限 & 继承权限

  

this指针

- `this`指针是一个隐式的指针，它指向当前对象的地址。
    
- 在成员函数中返回`*this`来返回当前对象本身，实现链式调用。
    

  

构造函数 & 析构函数

- 构造函数
    
    - 默认构造函数
        
    - 初始化构造函数
        
    - 拷贝构造函数
        
    - 移动构造函数
        
    - 委托构造函数
        
    - 转换构造函数
        
    - constexpr 修饰
        
    - explicit 修饰
        
- 析构函数：
    
    - 默认析构函数
        
    - 虚析构函数


类对象初始化顺序 & 析构顺序

  

三五法则

如果类不需要定义「析构函数」回收资源，则只需要定义「普通构造函数」。

如果类需要定义「析构函数」回收资源，则在定义「普通构造函数」外，也需要定义「拷贝构造函数、拷贝赋值运算函数」。

用户定义的「析构函数、拷贝构造函数、拷贝赋值运算符」的存在会阻止 「移动构造函数、移动赋值运算符」的隐式定义，所以任何想要移动语义的类必须声明全部五个特殊成员函数。

  

虚函数 & 纯虚函数

- 虚函数是基于「虚函数表」和「虚函数指针」实现。
    
- 当调用一个虚函数时，编译器会先检查对象的虚函数指针，然后根据该指针找到相应的虚函数表。最后，根据虚函数表中存储的函数地址，调用相应的虚函数实现代码。
    

  

多态的实现原理

  

  

单继承 & 多继承 & 菱形继承 & 虚继承

菱形继承：

- **数据冗余**：派生类对象中包含两个相同基类的成员。
    
- **二义性**：派生类调用基类函数时，无法确定调用哪个。
    

虚继承：用于解决菱形继承的问题。

  

对象内存布局（单继承 & 多继承）

  

类的大小

  

控制对象在堆或栈上分配

友元函数 & 友元类

# 语言特性

## C++11特性

RAII

引用计数

  

智能指针

- unique_ptr & shared_ptr & weak_ptr
    
- 值传递 & 引用传递
    
- unique_ptr
    
    - 避免使用 unique_ptr 作为值传递，通常是获取裸指针传递，或转移所有权
        
    - 如果一定要传递，也要使用引用传递
        
    - unique_ptr 作为返回值使用，设计模式中经常用到，异常安全
        
- shared_ptr
    
    - 避免循环引用问题，内部使用 weak_ptr
        
    - 作为值传递没问题，因为所有权不会发生变化
        

  

异常处理

  

左值与右值

  

右值引用、移动语义与完美转发

  

`auto` 类型推导

  

`decltype` 类型推导

  

`lambda` 表达式

  

默认构造函数 `= default`

禁用函数 `= delete`

`constexpr` 常量表达式

初始化列表`initializer list`

`nullptr` 空指针常量

可扩展的随机数功能

模板与泛型编程：模板定义、实例化、模板编译、模板特化

lambda表达式

  

C++14特性：

支持函数返回值类型推导

`lambda` 函数的形式参数允许泛型

`deprecated` 属性

新增`std::make_unique`

共享的互斥体和锁

  

C++ 17 新特性：

结构化绑定

`if-switch` 语句初始化

`constexpr lambda` 表达式

`namespace` 嵌套

`std::any`可以存储任何类型

`std::filesystem` 文件库

# IO处理

标准IO & 文件IO & 内存IO & 网络IO

标准IO：cin cout cerr

文件IO：ifstream ofstream fstream

内存IO：stringstream

网络IO：socket

# 多线程编程

锁的种类：互斥锁、条件锁、自选锁、读写锁、递归锁

  

# 编码规范

- 变量最好在定义时就初始化，并且使用 `{}` 显式初始化
    

# 工程化

include " " 与 <> 的区别

构建：make、cmake

调试：gdb

# 问题

static 的作用

const 的作用

sizeof 与 strlen 的区别

auto 推导的规则

  

new 与 mollac 的区别

delete 与 free 的区别

volatile 的作用与使用场景

  

class 与 struct 的区别

struct 与 union 的区别

class 与 struct 的区别

extern C 的作用

strcpy 的缺陷

lambda 表达式的作用

memmove 函数的底层原理

深拷贝和浅拷贝

友元函数

返回函数中静态变量的地址会发生什么

sizeof(1==1) 在 C 和 C++ 中的结果

memmove 函数的底层原理

  

explicit 的作用

define 与 typedef 的区别