**整型**

|           |     |                                              |
| --------- | --- | -------------------------------------------- |
| 类型       | 含义  | 最小尺寸                                         |
| short     | 短整型 | 16bits，通常为半个 int 的大小。                        |
| int       | 整型  | 16bits (在32位机器中是32bits)                      |
| long      | 长整型 | 32bits，通常为两个 int 的大小。                        |
| long long | 长整型 | 32bits，表示更长的整数，通常为两个 long 的大小。（是在C++11中新定义的） |

**浮点型**

|   |   |   |
|---|---|---|
|类型|含义|最小尺寸|
|float|单精度浮点数|通常为4字节，7 位有效数字|
|double|双精度浮点数|通常为8字节，10位有效数字|
|long double|扩展精度浮点数|16 字节或 32 字节， 10位有效数字|

**字符型**

|   |   |   |
|---|---|---|
|类型|含义|最小尺寸|
|char|字符|8bits，表示单个字符，存放机器基本字符集中的字符对应的数字值，一个 char 的大小和一个机器字节一样。|
|wchar_t|宽字符|16bits，表示宽字符，用于支持更多的字符编码。|
|char16_t|Unicode字符|16bits，用于支持 Unicode 字符。|
|char32_t|Unicode字符|32bits，用于支持 Unicode 字符。|

**布尔型**

|   |   |   |
|---|---|---|
|类型|含义|最小尺寸|
|bool|布尔类型|未定义，通常占用1个字节，可用sizeof计算，仅用最低位 00000001 表示。|

**无符号类型**

- 除了 **布尔类型** 和 **扩展字符型**外，其他 整数类型 可分为 **signed** 和**unsigned**。
- 类型 `int`、`short`、`long` 和 `long long` 默认都是带符号的，通过在类型名前面加上 `unsigned` 可以得到无符号的。
- 字符型可以分为三种 `char`、`signed char`和 `unsigned char`，特别要注意 `char` 和 `signed char` 并不一样，尽管字符型有三种，但实际的表现形式只有两种：`signed char` 和 `unsigned char`，类型 `char`根据编译器不同会表现为上面两种之一。
    

**如何选择正确的类型**

- 当明确知晓数值不可能是负数时，选用无符号类型。
    
- 使用`int`执行整数运算。一般`long`的大小和`int`一样，而`short`常常显得太小。如果超过了`int`的范围，选择`long long`。
    
- 算术表达式中不要使用`char`或`bool`，只有在存放字符或布尔值时才使用它们。因为类型`char`在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果使用`char`进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 `signed char` 或者 `unsigned char`。
    
- 执行浮点数运算选用 `double`，因为 `float` 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。`long double`提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。
    

**类型转换**

类型所能表示的值的范围决定了转换的过程：  

- 非布尔类型的算术值赋给布尔类型时，初始值为 0 则结果为 false，否则结果为 true；
    
- 布尔值赋给非布尔类型时，初始值为 false 则结果为 0，初始值为true则结果为1。
    
- 浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分；
    
- 整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
    
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。例如，8比特大小的 unsigned char 可以表示 0 至 255 区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，把 -1 赋给 8 比特大小的 unsigned char 所得的结果是255。
    
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined)。此时，程序可能继续工作，可能崩溃，也可能生成垃圾数据。
    
- 当一个算术表达式中既有无符号数又有 int 值时，那个 int 值就会转换成无符号数。
    
- 不要将带符号类型和无符号类型混用。
    

**值类型与引用类型**

这是另外一种类型的划分，值类型是指**那些在赋值或传递给函数时，其值会被复制**的类型。

值类型和引用类型的区别主要在于**赋值和传递给函数时的行为**：

- 值类型在赋值或传递给函数时，其值会被复制。
    
- 引用类型在赋值或传递给函数时，其值不会被复制，而是会将引用传递给目标对象。



**算术运算符**

加法`+` 
减法`-` 
乘法`*` 
除法`/` 
取余`**` 
自增`++` 
自减`--`

**逻辑运算符**

逻辑与`&` 
逻辑或`|` 
逻辑非`!`

**比较运算符**

等于`==` 
不等于`!=` 
小于`<` 
大于`>` 
小于等于`<=` 
大于等于`>=`

**位运算符**

与`&` 
或`|` 
异或`^`
非`~` 
左移`<<` 
右移`>>`

**成员访问运算符**

箭头`->` 
点`.`

**其他运算符**

赋值`=` 
下标`[]` 
函数调用`()`
逗号`,` 
新建`new` 
删除`delete`

类型转换 `const_cast`, `dynamic_cast`, `reinterpret_cast`, `static_cast`

  

**不可重载的运算符**

- 长度运算符`sizeof` （内部有很多指针依赖）
    
- 类成员访问运算符`.`
    
- 类成员指针访问运算符 `.*` `->*`
    
- 域运算符`::`（该运算符只是在编译的时候域解析，而没有运算的参与进来）
    
- 条件运算符`?:`


**标识符**

标识符是用于标识变量、函数、类等编程元素的名称。标识符必须由字母、数字或下划线开头，后面可以跟任意数量的字母、数字、下划线或点号。例如：

- `x`：一个变量名
    
- `myFunction`：一个函数名
    
- `MyClass`：一个类名


**运算符**

运算符用于执行各种操作，例如加减乘除、逻辑运算、比较运算等。


**操作数**

操作数是运算符作用的对象。操作数可以是变量、常量、表达式等。例如：

- `x + y`：表达式中，`x` 和 `y` 是操作数
    
- `10 * 20`：表达式中，`10` 和 `20` 是操作数


**表达式（expression）**

用于计算值, 是由运算符和操作数组成的代码片段. 表达式可以包含变量、常量、函数调用和其他表达式。表达式可以用于赋值、比较、计算等操作，并且可以作为语句的一部分。

```SQL
1 + 2
```

**语句（statement）**

用于执行操作, 语句是执行某个操作的完整指令,可以包含一个或多个表达式、控制结构、函数调用等。语句以分号（;）结尾，表示语句的结束。

语句是执行某个操作的完整指令。语句可以包含表达式，也可以不包含表达式。例如：

- `x = 10;`：赋值语句，将 10 赋给变量 `x`
    
- `std::cout << "Hello, world!" << std::endl;`：输出语句，将 "Hello, world!" 输出到控制台
    

**函数**

函数是一组用于执行特定任务的代码块。函数可以接受参数，并返回结果。例如：

C++

```Plaintext
int sum(int a, int b) {return a + b;
}

int main() {int x = sum(1, 2);return 0;
}
```


**类**

类是一种用户定义的数据类型，它可以包含数据成员和成员函数。类可以用于创建对象，对象是类的实例。


**声明（Declaration）**

声明是指告诉编译器某个符号的类型和名称，但并 **不会分配内存空间**。

声明可以出现在头文件中或者函数参数列表中。例如：

```C++
extern int a; // 声明一个名为a的整型变量
void func(int b); // 声明一个名为func的函数，参数为整型变量b
```

定义（Definition）

定义是指告诉编译器变量的类型和名称，并为其**分配内存空间**。

一个变量或对象只能在程序的某个地方进行定义一次。

```C++
int a; // 定义一个名为a的整型变量
int b = 1; // 定义一个名为b的整型变量，并初始化为1
void func(int b) { // 定义一个名为func的函数，参数为整型变量b
    // 函数体
}
```

### 初始化（Initialization）

初始化为**变量赋予初始值**。

```C++
int a = 1; // 定义一个名为a的整型变量，并初始化为1
int arr[] = {1, 2, 3}; // 定义一个名为arr的数组，并初始化为{1, 2, 3}
```

  

定义和初始化的区别在于：

- 定义是必须的，而初始化是可选的。
    
- 定义为变量分配内存空间，而初始化为变量赋予初始值。
    

  

在大多数情况下，定义和初始化是同时进行的，但是，也可以在定义之后再初始化变量。

```Go
int x;
x = 10;
```

  

问题1：`int a;` 是声明还是定义？

`int a;` 既是声明，也是定义。因为它告诉了编译器 `a` 是一个整数变量，并为 `a` 分配了内存空间。

分配了内存空间就是定义，没有分配内存空间就是声明。